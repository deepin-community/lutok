<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Lutok: lutok::state Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Lutok
   &#160;<span id="projectnumber">0.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>lutok</b></li><li class="navelem"><a class="el" href="a00009.html">state</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">lutok::state Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A RAII model for the Lua state.  
 <a href="a00009.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00028_source.html">state.hpp</a>&gt;</code></p>

<p><a href="a00048.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation for <a class="el" href="a00009.html" title="A RAII model for the Lua state.">lutok::state</a>.  <a href="a00010.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae952d08c75d4d07eef07fc00a608c4b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#ae952d08c75d4d07eef07fc00a608c4b4">state</a> (void)</td></tr>
<tr class="memdesc:ae952d08c75d4d07eef07fc00a608c4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Lua state.  <a href="#ae952d08c75d4d07eef07fc00a608c4b4"></a><br/></td></tr>
<tr class="memitem:a2b163a6db54c80d3ad1d8d324e7e7fe1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a2b163a6db54c80d3ad1d8d324e7e7fe1">~state</a> (void)</td></tr>
<tr class="memdesc:a2b163a6db54c80d3ad1d8d324e7e7fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for the Lua state.  <a href="#a2b163a6db54c80d3ad1d8d324e7e7fe1"></a><br/></td></tr>
<tr class="memitem:a16c2f95e91f64c5ac89258ee5dcd34e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a16c2f95e91f64c5ac89258ee5dcd34e2">close</a> (void)</td></tr>
<tr class="memdesc:a16c2f95e91f64c5ac89258ee5dcd34e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates this Lua session.  <a href="#a16c2f95e91f64c5ac89258ee5dcd34e2"></a><br/></td></tr>
<tr class="memitem:a0291a3b34c5bed860d8d53e54eaee349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a0291a3b34c5bed860d8d53e54eaee349">get_global</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a0291a3b34c5bed860d8d53e54eaee349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_getglobal.  <a href="#a0291a3b34c5bed860d8d53e54eaee349"></a><br/></td></tr>
<tr class="memitem:a2287f1dd03e6a72837ab020512927ee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a2287f1dd03e6a72837ab020512927ee6">get_global_table</a> (void)</td></tr>
<tr class="memdesc:a2287f1dd03e6a72837ab020512927ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a reference to the global table onto the stack.  <a href="#a2287f1dd03e6a72837ab020512927ee6"></a><br/></td></tr>
<tr class="memitem:a0d4f5204547cac3e4855e375f6bc64cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a0d4f5204547cac3e4855e375f6bc64cb">get_metafield</a> (const int, const std::string &amp;)</td></tr>
<tr class="memdesc:a0d4f5204547cac3e4855e375f6bc64cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around luaL_getmetafield.  <a href="#a0d4f5204547cac3e4855e375f6bc64cb"></a><br/></td></tr>
<tr class="memitem:abbbafa23bb49ccc04e0f32f47b629ae5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#abbbafa23bb49ccc04e0f32f47b629ae5">get_metatable</a> (const int)</td></tr>
<tr class="memdesc:abbbafa23bb49ccc04e0f32f47b629ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_getmetatable.  <a href="#abbbafa23bb49ccc04e0f32f47b629ae5"></a><br/></td></tr>
<tr class="memitem:a8865c4d7ee8a5d9f9ffeff22b8819648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a8865c4d7ee8a5d9f9ffeff22b8819648">get_table</a> (const int)</td></tr>
<tr class="memdesc:a8865c4d7ee8a5d9f9ffeff22b8819648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_gettable.  <a href="#a8865c4d7ee8a5d9f9ffeff22b8819648"></a><br/></td></tr>
<tr class="memitem:af8591bfdccb2e8732c147a8a6623b2e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#af8591bfdccb2e8732c147a8a6623b2e5">get_top</a> (void)</td></tr>
<tr class="memdesc:af8591bfdccb2e8732c147a8a6623b2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_gettop.  <a href="#af8591bfdccb2e8732c147a8a6623b2e5"></a><br/></td></tr>
<tr class="memitem:a69d7e97f6140c24382fbfd05aa16ad72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a69d7e97f6140c24382fbfd05aa16ad72">insert</a> (const int)</td></tr>
<tr class="memdesc:a69d7e97f6140c24382fbfd05aa16ad72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_insert.  <a href="#a69d7e97f6140c24382fbfd05aa16ad72"></a><br/></td></tr>
<tr class="memitem:a4efb903445d053766fe54800d36d4deb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a4efb903445d053766fe54800d36d4deb">is_boolean</a> (const int)</td></tr>
<tr class="memdesc:a4efb903445d053766fe54800d36d4deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_isboolean.  <a href="#a4efb903445d053766fe54800d36d4deb"></a><br/></td></tr>
<tr class="memitem:ab454ca52fec8413fde1d46df003c19c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#ab454ca52fec8413fde1d46df003c19c0">is_function</a> (const int)</td></tr>
<tr class="memdesc:ab454ca52fec8413fde1d46df003c19c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_isfunction.  <a href="#ab454ca52fec8413fde1d46df003c19c0"></a><br/></td></tr>
<tr class="memitem:a21c5f4f63cf89db0f16dd032f0612a78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a21c5f4f63cf89db0f16dd032f0612a78">is_nil</a> (const int)</td></tr>
<tr class="memdesc:a21c5f4f63cf89db0f16dd032f0612a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_isnil.  <a href="#a21c5f4f63cf89db0f16dd032f0612a78"></a><br/></td></tr>
<tr class="memitem:acd31e0953ee71c94903e5444bf451eb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#acd31e0953ee71c94903e5444bf451eb1">is_number</a> (const int)</td></tr>
<tr class="memdesc:acd31e0953ee71c94903e5444bf451eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_isnumber.  <a href="#acd31e0953ee71c94903e5444bf451eb1"></a><br/></td></tr>
<tr class="memitem:af82c354bbcedaa5f7b2f8b8e6f6c69b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#af82c354bbcedaa5f7b2f8b8e6f6c69b5">is_string</a> (const int)</td></tr>
<tr class="memdesc:af82c354bbcedaa5f7b2f8b8e6f6c69b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_isstring.  <a href="#af82c354bbcedaa5f7b2f8b8e6f6c69b5"></a><br/></td></tr>
<tr class="memitem:a468113870c8129430cbd773f5abb85fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a468113870c8129430cbd773f5abb85fa">is_table</a> (const int)</td></tr>
<tr class="memdesc:a468113870c8129430cbd773f5abb85fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_istable.  <a href="#a468113870c8129430cbd773f5abb85fa"></a><br/></td></tr>
<tr class="memitem:adea141de47b0e6895e8ee9afe5c82a0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#adea141de47b0e6895e8ee9afe5c82a0e">is_userdata</a> (const int)</td></tr>
<tr class="memdesc:adea141de47b0e6895e8ee9afe5c82a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_isuserdata.  <a href="#adea141de47b0e6895e8ee9afe5c82a0e"></a><br/></td></tr>
<tr class="memitem:a493b3192ade9e2f32940b96fa9ef461b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a493b3192ade9e2f32940b96fa9ef461b">load_file</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a493b3192ade9e2f32940b96fa9ef461b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around luaL_loadfile.  <a href="#a493b3192ade9e2f32940b96fa9ef461b"></a><br/></td></tr>
<tr class="memitem:a5ff9ef96d82c9cc497a8dfc1404a1c82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a5ff9ef96d82c9cc497a8dfc1404a1c82">load_string</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a5ff9ef96d82c9cc497a8dfc1404a1c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around luaL_loadstring.  <a href="#a5ff9ef96d82c9cc497a8dfc1404a1c82"></a><br/></td></tr>
<tr class="memitem:a50d389a2c6d23214eda1e46e15ed20b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a50d389a2c6d23214eda1e46e15ed20b5">new_table</a> (void)</td></tr>
<tr class="memdesc:a50d389a2c6d23214eda1e46e15ed20b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_newtable.  <a href="#a50d389a2c6d23214eda1e46e15ed20b5"></a><br/></td></tr>
<tr class="memitem:aaec7e57d4434f087cef8d38a221ae474"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:aaec7e57d4434f087cef8d38a221ae474"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00009.html#aaec7e57d4434f087cef8d38a221ae474">new_userdata</a> (void)</td></tr>
<tr class="memdesc:aaec7e57d4434f087cef8d38a221ae474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_newuserdata.  <a href="#aaec7e57d4434f087cef8d38a221ae474"></a><br/></td></tr>
<tr class="memitem:abbbcf3c19d7d29594ea2e61ece52b815"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#abbbcf3c19d7d29594ea2e61ece52b815">next</a> (const int)</td></tr>
<tr class="memdesc:abbbcf3c19d7d29594ea2e61ece52b815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_next.  <a href="#abbbcf3c19d7d29594ea2e61ece52b815"></a><br/></td></tr>
<tr class="memitem:a940ebd0fb37259360a63b7a669d8ca99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a940ebd0fb37259360a63b7a669d8ca99">open_all</a> (void)</td></tr>
<tr class="memdesc:a940ebd0fb37259360a63b7a669d8ca99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around luaL_openlibs.  <a href="#a940ebd0fb37259360a63b7a669d8ca99"></a><br/></td></tr>
<tr class="memitem:abf68c04d96308868fec71a628741c712"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#abf68c04d96308868fec71a628741c712">open_base</a> (void)</td></tr>
<tr class="memdesc:abf68c04d96308868fec71a628741c712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around luaopen_base.  <a href="#abf68c04d96308868fec71a628741c712"></a><br/></td></tr>
<tr class="memitem:a85db3b50e195e6ab7e81f9f51205d8c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a85db3b50e195e6ab7e81f9f51205d8c0">open_string</a> (void)</td></tr>
<tr class="memdesc:a85db3b50e195e6ab7e81f9f51205d8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around luaopen_string.  <a href="#a85db3b50e195e6ab7e81f9f51205d8c0"></a><br/></td></tr>
<tr class="memitem:a8898b62799b3b8a70a2b6a049e531515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a8898b62799b3b8a70a2b6a049e531515">open_table</a> (void)</td></tr>
<tr class="memdesc:a8898b62799b3b8a70a2b6a049e531515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around luaopen_table.  <a href="#a8898b62799b3b8a70a2b6a049e531515"></a><br/></td></tr>
<tr class="memitem:a307897e3501a5b5b08eb66f35f4d18df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a307897e3501a5b5b08eb66f35f4d18df">pcall</a> (const int, const int, const int)</td></tr>
<tr class="memdesc:a307897e3501a5b5b08eb66f35f4d18df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_pcall.  <a href="#a307897e3501a5b5b08eb66f35f4d18df"></a><br/></td></tr>
<tr class="memitem:ac07258b143ef607dd9f6a9e24e495c20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#ac07258b143ef607dd9f6a9e24e495c20">pop</a> (const int)</td></tr>
<tr class="memdesc:ac07258b143ef607dd9f6a9e24e495c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_pop.  <a href="#ac07258b143ef607dd9f6a9e24e495c20"></a><br/></td></tr>
<tr class="memitem:a11e9a3235154ebf867298935f1f58ca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a11e9a3235154ebf867298935f1f58ca5">push_boolean</a> (const bool)</td></tr>
<tr class="memdesc:a11e9a3235154ebf867298935f1f58ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_pushboolean.  <a href="#a11e9a3235154ebf867298935f1f58ca5"></a><br/></td></tr>
<tr class="memitem:a0e5b1b04d7bdf606a7b013b83de433d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a0e5b1b04d7bdf606a7b013b83de433d1">push_cxx_closure</a> (cxx_function, const int)</td></tr>
<tr class="memdesc:a0e5b1b04d7bdf606a7b013b83de433d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_pushcclosure.  <a href="#a0e5b1b04d7bdf606a7b013b83de433d1"></a><br/></td></tr>
<tr class="memitem:ae894e01dd1ff748aaf3f1a657363fe02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#ae894e01dd1ff748aaf3f1a657363fe02">push_cxx_function</a> (cxx_function)</td></tr>
<tr class="memdesc:ae894e01dd1ff748aaf3f1a657363fe02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_pushcfunction.  <a href="#ae894e01dd1ff748aaf3f1a657363fe02"></a><br/></td></tr>
<tr class="memitem:a5c5b08f88a143cb48a600c044e2e3a56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a5c5b08f88a143cb48a600c044e2e3a56">push_integer</a> (const int)</td></tr>
<tr class="memdesc:a5c5b08f88a143cb48a600c044e2e3a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_pushinteger.  <a href="#a5c5b08f88a143cb48a600c044e2e3a56"></a><br/></td></tr>
<tr class="memitem:a7e1219378038bf40f72533dd14946f63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e1219378038bf40f72533dd14946f63"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a7e1219378038bf40f72533dd14946f63">push_nil</a> (void)</td></tr>
<tr class="memdesc:a7e1219378038bf40f72533dd14946f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_pushnil. <br/></td></tr>
<tr class="memitem:a90859ee0fb17b13c3ebf4dfbfbee8c15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a90859ee0fb17b13c3ebf4dfbfbee8c15">push_string</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a90859ee0fb17b13c3ebf4dfbfbee8c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_pushstring.  <a href="#a90859ee0fb17b13c3ebf4dfbfbee8c15"></a><br/></td></tr>
<tr class="memitem:a48d4552a0e81c350b6ea1077018fc3fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a48d4552a0e81c350b6ea1077018fc3fe">push_value</a> (const int)</td></tr>
<tr class="memdesc:a48d4552a0e81c350b6ea1077018fc3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_pushvalue.  <a href="#a48d4552a0e81c350b6ea1077018fc3fe"></a><br/></td></tr>
<tr class="memitem:ad67d44dd8d7273cfce233731ad8f10d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#ad67d44dd8d7273cfce233731ad8f10d7">raw_get</a> (const int)</td></tr>
<tr class="memdesc:ad67d44dd8d7273cfce233731ad8f10d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_rawget.  <a href="#ad67d44dd8d7273cfce233731ad8f10d7"></a><br/></td></tr>
<tr class="memitem:aa81b48420e6749c8f957af9039df0b37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#aa81b48420e6749c8f957af9039df0b37">raw_set</a> (const int)</td></tr>
<tr class="memdesc:aa81b48420e6749c8f957af9039df0b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_rawset.  <a href="#aa81b48420e6749c8f957af9039df0b37"></a><br/></td></tr>
<tr class="memitem:ae8b4f75bb99611707739772417c36e5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#ae8b4f75bb99611707739772417c36e5a">set_global</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:ae8b4f75bb99611707739772417c36e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_setglobal.  <a href="#ae8b4f75bb99611707739772417c36e5a"></a><br/></td></tr>
<tr class="memitem:a9873b4860342a745a832f514ab803909"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a9873b4860342a745a832f514ab803909">set_metatable</a> (const int)</td></tr>
<tr class="memdesc:a9873b4860342a745a832f514ab803909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_setmetatable.  <a href="#a9873b4860342a745a832f514ab803909"></a><br/></td></tr>
<tr class="memitem:ac2467d43a04babb717b4d6d384cf074c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#ac2467d43a04babb717b4d6d384cf074c">set_table</a> (const int)</td></tr>
<tr class="memdesc:ac2467d43a04babb717b4d6d384cf074c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_settable.  <a href="#ac2467d43a04babb717b4d6d384cf074c"></a><br/></td></tr>
<tr class="memitem:a32129410bd9c2cd170d60919d203a639"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a32129410bd9c2cd170d60919d203a639">to_boolean</a> (const int)</td></tr>
<tr class="memdesc:a32129410bd9c2cd170d60919d203a639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_toboolean.  <a href="#a32129410bd9c2cd170d60919d203a639"></a><br/></td></tr>
<tr class="memitem:ad947a5fb78835427838e4e10b16cc34a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#ad947a5fb78835427838e4e10b16cc34a">to_integer</a> (const int)</td></tr>
<tr class="memdesc:ad947a5fb78835427838e4e10b16cc34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_tointeger.  <a href="#ad947a5fb78835427838e4e10b16cc34a"></a><br/></td></tr>
<tr class="memitem:a0d7c94591101c42e93726ef7999eb11d"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a0d7c94591101c42e93726ef7999eb11d"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00009.html#a0d7c94591101c42e93726ef7999eb11d">to_userdata</a> (const int)</td></tr>
<tr class="memdesc:a0d7c94591101c42e93726ef7999eb11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_touserdata.  <a href="#a0d7c94591101c42e93726ef7999eb11d"></a><br/></td></tr>
<tr class="memitem:aa40dd851d1e2323c55356506922e7b60"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#aa40dd851d1e2323c55356506922e7b60">to_string</a> (const int)</td></tr>
<tr class="memdesc:aa40dd851d1e2323c55356506922e7b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_tostring.  <a href="#aa40dd851d1e2323c55356506922e7b60"></a><br/></td></tr>
<tr class="memitem:a1210a0875bde2a0452dd4813573b8865"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a1210a0875bde2a0452dd4813573b8865">upvalue_index</a> (const int)</td></tr>
<tr class="memdesc:a1210a0875bde2a0452dd4813573b8865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_upvalueindex.  <a href="#a1210a0875bde2a0452dd4813573b8865"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5f2fa48408831695914e4a57acf85a7c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a5f2fa48408831695914e4a57acf85a7c">new_userdata_voidp</a> (const size_t)</td></tr>
<tr class="memdesc:a5f2fa48408831695914e4a57acf85a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_newuserdata.  <a href="#a5f2fa48408831695914e4a57acf85a7c"></a><br/></td></tr>
<tr class="memitem:a4054e2df5af0cc5db61c7560637406ea"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a4054e2df5af0cc5db61c7560637406ea">to_userdata_voidp</a> (const int)</td></tr>
<tr class="memdesc:a4054e2df5af0cc5db61c7560637406ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around lua_touserdata.  <a href="#a4054e2df5af0cc5db61c7560637406ea"></a><br/></td></tr>
<tr class="memitem:a526b2171768d4d214b6f8f4d0ed2cf1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a526b2171768d4d214b6f8f4d0ed2cf1e">state</a> (void *)</td></tr>
<tr class="memdesc:a526b2171768d4d214b6f8f4d0ed2cf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Lua state from an existing raw state.  <a href="#a526b2171768d4d214b6f8f4d0ed2cf1e"></a><br/></td></tr>
<tr class="memitem:a2b577a4a090b67aa5b9b7a3f0762ca18"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a2b577a4a090b67aa5b9b7a3f0762ca18">raw_state</a> (void)</td></tr>
<tr class="memdesc:a2b577a4a090b67aa5b9b7a3f0762ca18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the internal lua_State object.  <a href="#a2b577a4a090b67aa5b9b7a3f0762ca18"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8186e860494a2eabf487c28693c494d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8186e860494a2eabf487c28693c494d4"></a>
std::tr1::shared_ptr&lt; <a class="el" href="a00010.html">impl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html#a8186e860494a2eabf487c28693c494d4">_pimpl</a></td></tr>
<tr class="memdesc:a8186e860494a2eabf487c28693c494d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the shared internal implementation. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1664309d3bb0137c1facd2595acf39e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1664309d3bb0137c1facd2595acf39e2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>state_c_gate</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A RAII model for the Lua state. </p>
<p>This class holds the state of the Lua interpreter during its existence and provides wrappers around several Lua library functions that operate on such state.</p>
<p>These wrapper functions differ from the C versions in that they use the implicit state hold by the class, they use C++ types where appropriate and they use exceptions to report errors.</p>
<p>The wrappers intend to be as lightweight as possible but, in some situations, they are pretty complex because they need to do extra work to capture the errors reported by the Lua C API. We prefer having fine-grained error control rather than efficiency, so this is OK. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a526b2171768d4d214b6f8f4d0ed2cf1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lutok::state::state </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>raw_state_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the Lua state from an existing raw state. </p>
<p>Instances constructed using this method do NOT own the raw state. This means that, on exit, the state will not be destroyed.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_state_</td><td>The raw Lua state to wrap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae952d08c75d4d07eef07fc00a608c4b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lutok::state::state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the Lua state. </p>
<p>You must share the same state object alongside the lifetime of your Lua session. As soon as the object is destroyed, the session is terminated. </p>

</div>
</div>
<a class="anchor" id="a2b163a6db54c80d3ad1d8d324e7e7fe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lutok::state::~state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for the Lua state. </p>
<p>Closes the session unless it has already been closed by calling the <a class="el" href="a00009.html#a16c2f95e91f64c5ac89258ee5dcd34e2" title="Terminates this Lua session.">close()</a> method. It is recommended to explicitly close the session in the code. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a16c2f95e91f64c5ac89258ee5dcd34e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates this Lua session. </p>
<p>It is recommended to call this instead of relying on the destructor to do the cleanup, but it is not a requirement to use <a class="el" href="a00009.html#a16c2f95e91f64c5ac89258ee5dcd34e2" title="Terminates this Lua session.">close()</a>.</p>
<dl class="section pre"><dt>Precondition:</dt><dd><a class="el" href="a00009.html#a16c2f95e91f64c5ac89258ee5dcd34e2" title="Terminates this Lua session.">close()</a> has not yet been called. </dd>
<dd>
The Lua stack is empty. This is not truly necessary but ensures that our code is consistent and clears the stack explicitly. </dd></dl>

</div>
</div>
<a class="anchor" id="a0291a3b34c5bed860d8d53e54eaee349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::get_global </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_getglobal. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The second parameter to lua_getglobal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00002.html" title="Exception for errors raised by the Lua API library.">api_error</a></td><td>If lua_getglobal fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory to manipulate the Lua stack. </dd></dl>

</div>
</div>
<a class="anchor" id="a2287f1dd03e6a72837ab020512927ee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::get_global_table </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a reference to the global table onto the stack. </p>
<p>This is a wrapper around the incompatible differences between Lua 5.1 and 5.2 to access to the globals table.</p>
<dl class="section post"><dt>Postcondition:</dt><dd>state(-1) Contains the reference to the globals table. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d4f5204547cac3e4855e375f6bc64cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lutok::state::get_metafield </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around luaL_getmetafield. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to luaL_getmetafield. </td></tr>
    <tr><td class="paramname">name</td><td>The third parameter to luaL_getmetafield.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of luaL_getmetafield.</dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory to manipulate the Lua stack. </dd></dl>

</div>
</div>
<a class="anchor" id="abbbafa23bb49ccc04e0f32f47b629ae5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lutok::state::get_metatable </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_getmetatable. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_getmetatable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_getmetatable. </dd></dl>

</div>
</div>
<a class="anchor" id="a8865c4d7ee8a5d9f9ffeff22b8819648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::get_table </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_gettable. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_gettable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00002.html" title="Exception for errors raised by the Lua API library.">api_error</a></td><td>If lua_gettable fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory to manipulate the Lua stack. </dd></dl>

</div>
</div>
<a class="anchor" id="af8591bfdccb2e8732c147a8a6623b2e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lutok::state::get_top </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_gettop. </p>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_gettop. </dd></dl>

</div>
</div>
<a class="anchor" id="a69d7e97f6140c24382fbfd05aa16ad72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::insert </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_insert. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4efb903445d053766fe54800d36d4deb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lutok::state::is_boolean </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_isboolean. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_isboolean.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_isboolean. </dd></dl>

</div>
</div>
<a class="anchor" id="ab454ca52fec8413fde1d46df003c19c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lutok::state::is_function </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_isfunction. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_isfunction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_isfunction. </dd></dl>

</div>
</div>
<a class="anchor" id="a21c5f4f63cf89db0f16dd032f0612a78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lutok::state::is_nil </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_isnil. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_isnil.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_isnil. </dd></dl>

</div>
</div>
<a class="anchor" id="acd31e0953ee71c94903e5444bf451eb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lutok::state::is_number </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_isnumber. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_isnumber.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_isnumber. </dd></dl>

</div>
</div>
<a class="anchor" id="af82c354bbcedaa5f7b2f8b8e6f6c69b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lutok::state::is_string </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_isstring. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_isstring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_isstring. </dd></dl>

</div>
</div>
<a class="anchor" id="a468113870c8129430cbd773f5abb85fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lutok::state::is_table </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_istable. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_istable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_istable. </dd></dl>

</div>
</div>
<a class="anchor" id="adea141de47b0e6895e8ee9afe5c82a0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lutok::state::is_userdata </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_isuserdata. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_isuserdata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_isuserdata. </dd></dl>

</div>
</div>
<a class="anchor" id="a493b3192ade9e2f32940b96fa9ef461b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::load_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around luaL_loadfile. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The second parameter to luaL_loadfile.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00002.html" title="Exception for errors raised by the Lua API library.">api_error</a></td><td>If luaL_loadfile returns an error. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00006.html" title="File not found error.">file_not_found_error</a></td><td>If the file cannot be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ff9ef96d82c9cc497a8dfc1404a1c82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::load_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around luaL_loadstring. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The second parameter to luaL_loadstring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00002.html" title="Exception for errors raised by the Lua API library.">api_error</a></td><td>If luaL_loadstring returns an error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a50d389a2c6d23214eda1e46e15ed20b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::new_table </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_newtable. </p>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="aaec7e57d4434f087cef8d38a221ae474"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type * lutok::state::new_userdata </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_newuserdata. </p>
<p>This allocates an object as big as the size of the provided Type.</p>
<dl class="section return"><dt>Returns:</dt><dd>The pointer to the allocated userdata object.</dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f2fa48408831695914e4a57acf85a7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * lutok::state::new_userdata_voidp </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around lua_newuserdata. </p>
<p>This is internal. The public type-safe interface of this method should be used instead.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The second parameter to lua_newuserdata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_newuserdata.</dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="abbbcf3c19d7d29594ea2e61ece52b815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lutok::state::next </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_next. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_next.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>True if there are more elements to process; false otherwise.</dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a940ebd0fb37259360a63b7a669d8ca99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::open_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around luaL_openlibs. </p>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00002.html" title="Exception for errors raised by the Lua API library.">api_error</a></td><td>If luaL_openlibs fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="abf68c04d96308868fec71a628741c712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::open_base </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around luaopen_base. </p>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00002.html" title="Exception for errors raised by the Lua API library.">api_error</a></td><td>If luaopen_base fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a85db3b50e195e6ab7e81f9f51205d8c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::open_string </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around luaopen_string. </p>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00002.html" title="Exception for errors raised by the Lua API library.">api_error</a></td><td>If luaopen_string fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a8898b62799b3b8a70a2b6a049e531515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::open_table </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around luaopen_table. </p>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00002.html" title="Exception for errors raised by the Lua API library.">api_error</a></td><td>If luaopen_table fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a307897e3501a5b5b08eb66f35f4d18df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::pcall </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nresults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>errfunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_pcall. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">nargs</td><td>The second parameter to lua_pcall. </td></tr>
    <tr><td class="paramname">nresults</td><td>The third parameter to lua_pcall. </td></tr>
    <tr><td class="paramname">errfunc</td><td>The fourth parameter to lua_pcall.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00002.html" title="Exception for errors raised by the Lua API library.">api_error</a></td><td>If lua_pcall returns an error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac07258b143ef607dd9f6a9e24e495c20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::pop </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_pop. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The second parameter to lua_pop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11e9a3235154ebf867298935f1f58ca5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::push_boolean </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_pushboolean. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The second parameter to lua_pushboolean. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e5b1b04d7bdf606a7b013b83de433d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::push_cxx_closure </td>
          <td>(</td>
          <td class="paramtype">cxx_function&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nvalues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_pushcclosure. </p>
<p>This is not a pure wrapper around lua_pushcclosure because this has to do extra magic to allow passing C++ functions instead of plain C functions.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The C++ function to be pushed as a closure. </td></tr>
    <tr><td class="paramname">nvalues</td><td>The number of upvalues that the function receives. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae894e01dd1ff748aaf3f1a657363fe02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::push_cxx_function </td>
          <td>(</td>
          <td class="paramtype">cxx_function&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_pushcfunction. </p>
<p>This is not a pure wrapper around lua_pushcfunction because this has to do extra magic to allow passing C++ functions instead of plain C functions.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The C++ function to be pushed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c5b08f88a143cb48a600c044e2e3a56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::push_integer </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_pushinteger. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The second parameter to lua_pushinteger. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90859ee0fb17b13c3ebf4dfbfbee8c15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::push_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_pushstring. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The second parameter to lua_pushstring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a48d4552a0e81c350b6ea1077018fc3fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::push_value </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_pushvalue. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_pushvalue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad67d44dd8d7273cfce233731ad8f10d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::raw_get </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_rawget. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_rawget. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa81b48420e6749c8f957af9039df0b37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::raw_set </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_rawset. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_rawset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory to manipulate the Lua stack. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b577a4a090b67aa5b9b7a3f0762ca18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * lutok::state::raw_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the internal lua_State object. </p>
<dl class="section return"><dt>Returns:</dt><dd>The raw Lua state. This is returned as a void pointer to prevent including the lua.hpp header file from our public interface. The only way to call this method is by using the c_gate module, and c_gate takes care of casting this object to the appropriate type. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8b4f75bb99611707739772417c36e5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::set_global </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_setglobal. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The second parameter to lua_setglobal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00002.html" title="Exception for errors raised by the Lua API library.">api_error</a></td><td>If lua_setglobal fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory to manipulate the Lua stack. </dd></dl>

</div>
</div>
<a class="anchor" id="a9873b4860342a745a832f514ab803909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::set_metatable </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_setmetatable. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_setmetatable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2467d43a04babb717b4d6d384cf074c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lutok::state::set_table </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_settable. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_settable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a00002.html" title="Exception for errors raised by the Lua API library.">api_error</a></td><td>If lua_settable fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory to manipulate the Lua stack. </dd></dl>

</div>
</div>
<a class="anchor" id="a32129410bd9c2cd170d60919d203a639"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lutok::state::to_boolean </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_toboolean. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_toboolean.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_toboolean. </dd></dl>

</div>
</div>
<a class="anchor" id="ad947a5fb78835427838e4e10b16cc34a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long lutok::state::to_integer </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_tointeger. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_tointeger.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_tointeger. </dd></dl>

</div>
</div>
<a class="anchor" id="aa40dd851d1e2323c55356506922e7b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string lutok::state::to_string </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_tostring. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_tostring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_tostring.</dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d7c94591101c42e93726ef7999eb11d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type * lutok::state::to_userdata </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_touserdata. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_touserdata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_touserdata. </dd></dl>

</div>
</div>
<a class="anchor" id="a4054e2df5af0cc5db61c7560637406ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * lutok::state::to_userdata_voidp </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around lua_touserdata. </p>
<p>This is internal. The public type-safe interface of this method should be used instead.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The second parameter to lua_touserdata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_touserdata.</dd></dl>
<dl class="section warning"><dt>Warning:</dt><dd>Terminates execution if there is not enough memory. </dd></dl>

</div>
</div>
<a class="anchor" id="a1210a0875bde2a0452dd4813573b8865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lutok::state::upvalue_index </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around lua_upvalueindex. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The first parameter to lua_upvalueindex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of lua_upvalueindex. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00028_source.html">state.hpp</a></li>
<li>state.cpp</li>
<li>state.ipp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 7 2013 19:02:36 for Lutok by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
